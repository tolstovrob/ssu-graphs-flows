#import "@preview/touying:0.6.1": *
#import themes.simple: *

#show: simple-theme.with(
  aspect-ratio: "16-9",
  primary: black,
  header-right: "Потоки",
  header: none,
  footer: "Теория графов",
)

#set text(size: 20pt)

#show raw.where(block: true): code => {
  show raw.line: line => {
    context {
      let t = text(fill: gray, size: 14pt)[#line.number]
      t
      h(2em - measure(t).width)
    }
    line.body
  }
  code
}

#show raw: set text(
  font: "JetBrainsMono NF",
  ligatures: false,
  size: 14pt,
  features: (calt: 0),
)

#title-slide[
  = Сети. Потоки в сетях
  #v(2em)
  
  Толстов Роберт Сергеевич,\
  Рудяк Артём Станиславович.
]

Для ситуаций, когда *важна пропускная способность рёбер* была описана теория потоковых сетей.

#pause

В рамках данной лекции мы успеем:

#pause
- познакомиться с теоретическими основами;
#pause
- рассмотреть ключевые практические задачи теории потоков;
#pause
- изучить алгоритмы для их решения.

== Теоретические основы

/ Сеть $G = angle.l V, E angle.r$: --- это ориентированный граф, такой что:

$ forall (u, v) in E quad c(u,v) > 0; $
$ forall (u, v) in.not E quad c(u,v) = 0. $

Функцию $c(u, v)$ называют *пропускной способностью* ребра $(u, v)$.

#pause

В сетях выделяют две вершины: исток $s$ и сток $t$.

---

/ Поток $f$ в сети $G$: --- это функция $f : V times V -> RR_(gt.eq.slant 0)$#pause, такая что $forall u, v in V$:

1. $f(u, v) = -f(v, u)$ (антисимметричность);
#pause
2. $f(u, v) <= c(u, v)$;

#pause

/ Величина потока: --- это объём потока, выходящий из истока. $|f| = limits(sum)_(u in V) f(s, v)$.

---

/ Закон сохранения потока.: Для сети $G = angle.l V, E angle.r$ с потоком $f$ верно, что:

$ forall v in V \\ {s, t} quad limits(sum_(u in V\ (u, v) in E)) f(u, v) = limits(sum_(w in V\ (v, w) in E)) f(v, w). $

#pause

Проще говоря, сумма входящих потоков равна сумме выходящих. Очевидно, что выполняется для всех вершин кроме истока и стока.

---

#figure(
  image("../images/flow-example.png", width: 85%),
)

= Интерактив на крутой суперприз

== Вопросы

+ *Что такое источник?* #pause Вершина, из которой исходит поток
#pause

+ *Что такое сток?* #pause Вершина, в которую поток должен поступить
#pause

+ *Что такое пропускная способность?* #pause Максимальный объём потока, разрешённый на дуге
#pause

+ *Что такое поток?* #pause Реальное значение ресурса, которое протекает по дуге. 

== Задача максимального потока

/ Задача.: Пусть дана сеть $G = angle.l V, E angle.r$. Требуется найти функцию потока:

$ f_max = limits(max)_f |f|, $

которая, очевидно, удовлетворяет всем свойствам функции потока. Такую функцию и называют функцией максимального потока.

#pause

Далее рассмотрим различные алгоритмы для решения этой задачи.

= Алгоритм Форда-Фалкерсона

== Алгоритм Форда-Фалкерсона

Данный алгоритм основан на итеративном поиске увеличивающих путей -- путей от источника к стоку в остаточной сети, по которым можно дополнительно провести поток.

#pause
- *Увеличивающим путём* называют путь из $s$ в $t$ остаточной сети, по которому каждая дуга имеет положительную остаточную пропускную способность. Таким образом, по данному пути можно увеличить поток.
#pause
- *Остаточной сетью* называется вспомогательный граф, показывающий, сколько еще можно накачать по ребру. Для каждого ребра определяют остаточную пропускную способность $c_f (u, v) = c(u, v) - f(u, v)$

---

#pause
+ Все потоки выставляем в 0.
#pause
+ В остаточной сети находим любой путь из источника в сток. Если нет, то останавливаемся
#pause
+ На найденном *увеличивающем пути* пускаем максимально возможный поток
  #pause
  + На найденном пути ищем ребро с минимальной пропускной способностью $c_"min"$
  #pause
  + Для каждого ребра на пути увеличиваем поток на $c_"min"$, а противоположный ему уменьшаем на эту величину.
  #pause
  + Для всех рёбер на найденном пути, а также для противоположных им, вычисляем новую пропускную способность. Если она ненулевая, то добавляем ребро к остаточной сети, а если обнулилась, то стираем.
#pause
+ Возвращаемся на шаг 2.

---

```
func FordFulkerson(G, s, t):
  для всех рёбер (u, v) в G:
    f(u, v) := 0

  пока существует увеличивающий путь P из s в t в остаточной сети G_f:
    delta := min(c_f(u, v), (u, v)) // бутылочное горлышко
    для (u, v) в P:
      f(u, v) := f(u, v) + delta // увеличиваем по прямому
      f(v, u) := f(v, u) - delta // уменьшаем по обратному
  вернуть сумму потоков, выходящих из s
```

---

#image("../images/ff1.png", width: 75%)

---

#image("../images/ff2.png", width: 75%)

---

#image("../images/ff3.png", width: 75%)

---

#image("../images/ff4.png", width: 75%)

---

#image("../images/ff5.png", width: 75%)

---

#image("../images/ff6.png", width: 75%)

---

#image("../images/ff7.png", width: 75%)

---

#image("../images/ff8.png", width: 75%)

== Недостатки
#pause
Так как алгоритм не предписывает, как именно искать путь в остаточной сети, то в худших случаях это может приводить к выбору "плохих" увеличивающих путей, по одному единичному потоку за итерацию. Ну и время работы алгоритма напрямую зависит от величины максимального потока. Если максимальный поток очень большой, то алгоритм может работать долго.

#pause
Что более важно, так это то, что алгоритм корректно работает разве что на целочисленных значениях потока, а на иррациональных и вовсе не завершиться.

#pause
Все эти недостатки привели к появлению новых алгоритмов, среди которых алгоритм Эдмондса-Карпа.

= Алгоритм Эдмондса-Карпа

== Алгоритм Эдмондса-Карпа
Это по сути реализация метода Форда-Фалкерсона, в которой в качестве увеличивающего пути выбирается кратчайший по рёбрам путь в остаточной сети. Алгоритмическая сложность такого решения соста вляет $O(V E^2)$

---

#image("../images/compare_ff_ed.png")

= Алгоритм масштабирования потока

== Алгоритм масштабирования потока

Ещё одна доработка метода Форда-Фалкерсона. Она заключается в том, чтобы сначала пускать поток по более пропускным путям. Т.е. выдавая им более высокий приоритет, нежели путям с низкой пропускной способностью.

#pause
Ключевым нововведением этого алгоритма является параметр масштаба пути $Delta$, который инициализируется максимальной степенью двойки, не превосходящей максимальную пропускную способность $U = limits(max)_((u, v) in E) c (u, v)$ сети.

---

```
func FordFulkerson(G, s, t):
  для всех рёбер (u, v) в G:
    f(u, v) := 0

  пока существует увеличивающий путь P из s в t в остаточной сети G_f:
    delta := min(c_f(u, v), (u, v)) // бутылочное горлышко
    для (u, v) в P:
      f(u, v) := f(u, v) + delta // увеличиваем по прямому
      f(v, u) := f(v, u) - delta // уменьшаем по обратному
  вернуть сумму потоков, выходящих из s
```

#pause
Очевидно, что при $"scale" = 1$ алгоритм превращается в классический метод Форда-Фалкерсона.

= А зачем всё это?

== Применение алгоритмов
Области применения алгоритмов поиска максимального потока довольно очeвидны:

#pause
- Транспортные сети. Например, при перевозке товаров от поставщика между распределительными пунктами до заказчика.
#pause
- Сетевые задачи. Определение максимальной пропускной способности компьютерной сети.
#pause
В целом любые сети, в которых требуется перегон какого-то ресурса из одной точки в другую через лимитированные по пропускной способности пути, подходят под алгоритм поиска максимального потока.

== Немного о мультипотоках

Кроме классических потоках в графах можно рассматривать и мультипотоки -- это расширение классической теории потоков в сетях, где одновременно рассматривается несколько типов потоков (товаров, ресурсов), каждый со своим источником и стоком. 

#pause
Как вместить несколько потоков разного рода в одну сеть так, чтобы суммарный поток через каждое ребро не превышал его пропускную способность?

---

Для графа $G = (V, E)$ с пропускными способностями $c(u, v)$ определяется поток для каждого товара $k$ как $f_k (u, v)$ удовлетворяющий:
#pause
- $limits(sum)_k f_k (u, v) lt.eq.slant c(u, v)$
#pause
- Закон сохранения: $limits(sum)_u f_k (u, v) = limits(sum)_w f_k (v, w)$ для вершин, кроме источника и стока товара k.
#pause
- Поток $f_k (u, v) gt.eq.slant 0$

= А это зачем?

== Потоки с затратами (задача минимизации стоимости потока)
Пусть каждому ребру графа приписывается не только пропускная способность, но и стоимость прохождения единицы потока.

Требуется найти поток заданной величины (или максимальный поток), минимизируя суммарные затраты.

---

Пример задачи:

_Рассмотрим транспортную сеть, где требуется привезти заданное количество товара из Китая (источник s) в ПВЗ Wildberries (сток t). Каждое ребро $(u, v)$ имеет:_
- _Пропускную способность $c(u, v)$ -- максимальный объем заказов, который можно перевезти по этой дороге (ребру)_.
- _Стоимость $a(u, v)$ -- цена перевозки одного заказа по этой дороге._
_Требуется найти поток величиной d, который достигает стока, при этом минимизируя суммарную стоимость транспортировки:_
$ min limits(sum)_((u, v)) a(u, v) dot f(u, v) $

---

Для решения такой задачи можно использовать алгоритм Форда-Фалкерсона или Эдмондса-Карпа, в котором на каждом шаге ищется путь с минимальным удорожанием, по которому можно увеличить поток.

== Вариации задач на мултипотоки
Все те же задачи оптимизации распределения разных ресурсов. Например, распределения товаров по одной логичестической сети или производственные процессы с несколькими потоками сырья и продуктов.

В таких задачах часто используется принцип разделения потоков, когда мультипоток разбивается на несколько сетей, в которых требуется определить максимальный поток.

= Итоги

== Домашнее задание

#pause
+ Реализовать на любом языке программирование один из алгоритмов в данной лекции
#pause
+ Найти максимальный поток в графе:

---

#image("photo_2025-10-31_12-22-08.jpg", width: 80%)

Домашнее задание по графам:

По два примера гетерогенного и гомогенного графа. Взять по одному гетерогенному и гомогенному графу и привести пример задачи на уровне всего графа, вершин, ребер

= Спасибо за внимание. Вопросы?

= Приз BMW x5 за лучший вопрос